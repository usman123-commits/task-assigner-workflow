{
  "name": "PHASE 2 – Cleaner Assignment + Calendar Dispatch",
  "nodes": [
    {
      "parameters": {},
      "id": "phase2-manual-trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [0, 300],
      "notes": "Replace with Schedule Trigger (e.g. every 5 min) for production. Kept Manual for testing."
    },
    {
      "parameters": {
        "operation": "read",
        "documentId": { "__rl": true, "value": "REPLACE_WITH_YOUR_SPREADSHEET_ID", "mode": "id" },
        "sheetName": { "__rl": true, "value": "cleaning_job", "mode": "name" },
        "filtersUI": {
          "values": [
            { "lookupColumn": "cleaningStatus", "lookupValue": "PENDING" }
          ]
        },
        "options": {}
      },
      "id": "phase2-read-cleaning-jobs",
      "name": "Read Pending Cleaning Jobs",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [220, 300],
      "credentials": { "googleSheetsOAuth2Api": { "id": "REPLACE_GOOGLE_CREDENTIAL_ID", "name": "Google Sheets account" } },
      "notes": "Reads cleaning_job rows where cleaningStatus = PENDING. Filter empty cleanerId in next node."
    },
    {
      "parameters": {
        "jsCode": "// Only process rows that are PENDING and have no cleaner assigned (and no event yet).\nconst items = $input.all();\nconst filtered = items.filter(item => {\n  const j = item.json || {};\n  const status = (j.cleaningStatus ?? '').toString().trim();\n  const cleanerId = (j.cleanerId ?? '').toString().trim();\n  const hasEvent = (j.calendarEventId ?? '').toString().trim() !== '';\n  return status === 'PENDING' && cleanerId === '' && !hasEvent;\n});\nreturn filtered;"
      },
      "id": "phase2-filter-pending",
      "name": "Filter Pending Only",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 300],
      "notes": "Ensures we only process PENDING + empty cleanerId. Skips if calendarEventId already set (no duplicate events)."
    },
    {
      "parameters": { "batchSize": 1, "options": {} },
      "id": "phase2-split-batches",
      "name": "Split In Batches",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [660, 300],
      "notes": "Process one cleaning job at a time to avoid overwrites and allow clear error scope."
    },
    {
      "parameters": {
        "operation": "read",
        "documentId": { "__rl": true, "value": "REPLACE_WITH_YOUR_SPREADSHEET_ID", "mode": "id" },
        "sheetName": { "__rl": true, "value": "reservation", "mode": "name" },
        "filtersUI": { "values": [{ "lookupColumn": "bookingUid", "lookupValue": "={{ $json.bookingUid }}" }] },
        "options": {}
      },
      "id": "phase2-lookup-reservation",
      "name": "Lookup Reservation",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [880, 200],
      "credentials": { "googleSheetsOAuth2Api": { "id": "REPLACE_GOOGLE_CREDENTIAL_ID", "name": "Google Sheets account" } },
      "notes": "Enriches with reservation data: propertyName, address (if columns exist). Merge in next node."
    },
    {
      "parameters": {
        "jsCode": "// If Lookup returned 0 rows or empty row, use job only with fallbacks. Otherwise use first lookup row.\nconst job = $('Split In Batches').last().json;\nconst items = $input.all();\nconst hasReservation = items.length > 0 && items[0].json?.bookingUid;\nconst lookup = hasReservation ? items[0].json : {};\nconst merged = { ...job, ...lookup, propertyName: lookup.propertyName ?? job.propertyName ?? job.propertyUid, address: lookup.address ?? job.address ?? 'Address TBD' };\nreturn [{ json: merged }];"
      },
      "id": "phase2-ensure-one-item",
      "name": "Ensure One Item (Job or Reservation)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [990, 200],
      "notes": "When Lookup returns no row, pass job only with propertyName/address fallbacks so Assign Cleaner still runs."
    },
    {
      "parameters": {
        "jsCode": "// Merge cleaning job (from Split In Batches) with reservation (from Ensure One Item).\nconst job = $('Split In Batches').last().json;\nconst lookup = $input.first().json;\nconst merged = { ...job, ...lookup };\nreturn [{ json: merged }];"
      },
      "id": "phase2-merge-job-reservation",
      "name": "Merge Job and Reservation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 200],
      "notes": "One item: cleaning job + reservation fields for propertyName, address, etc."
    },
    {
      "parameters": {
        "jsCode": "// STEP 2 — Assign cleaner by propertyUid. Expand PROPERTY_TO_CLEANER for more properties.\nconst PROPERTY_TO_CLEANER = {\n  'property-uid-1': { cleanerId: 'C1', email: 'cleaner1@example.com', calendarId: 'cleaner1@group.calendar.google.com' },\n  'property-uid-2': { cleanerId: 'C2', email: 'cleaner2@example.com', calendarId: 'cleaner2@group.calendar.google.com' }\n};\nconst item = $input.first().json;\nconst propertyUid = (item.propertyUid ?? '').toString().trim();\nconst mapping = PROPERTY_TO_CLEANER[propertyUid];\nif (!mapping) {\n  throw new Error(`No cleaner mapping for propertyUid: ${propertyUid}. Add to PROPERTY_TO_CLEANER.`);\n}\nconst assignedAt = new Date().toISOString();\nreturn [{\n  json: {\n    ...item,\n    cleanerId: mapping.cleanerId,\n    cleanerEmail: mapping.email,\n    cleanerCalendarId: mapping.calendarId,\n    assignedAt,\n    cleaningStatus: 'ASSIGNED'\n  }\n}];"
      },
      "id": "phase2-assign-cleaner",
      "name": "Assign Cleaner",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 200],
      "notes": "Static mapping propertyUid → cleanerId, email, calendarId. Update PROPERTY_TO_CLEANER for your properties."
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": { "__rl": true, "value": "REPLACE_WITH_YOUR_SPREADSHEET_ID", "mode": "id" },
        "sheetName": { "__rl": true, "value": "cleaning_job", "mode": "name" },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "bookingUid": "={{ $json.bookingUid }}",
            "cleanerId": "={{ $json.cleanerId }}",
            "assignedAt": "={{ $json.assignedAt }}",
            "cleaningStatus": "={{ $json.cleaningStatus }}"
          },
          "matchingColumns": ["bookingUid"]
        },
        "options": {}
      },
      "id": "phase2-update-job-assigned",
      "name": "Update Job Assigned",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [1540, 200],
      "credentials": { "googleSheetsOAuth2Api": { "id": "REPLACE_GOOGLE_CREDENTIAL_ID", "name": "Google Sheets account" } },
      "notes": "Update by bookingUid. Only sets cleanerId, assignedAt, cleaningStatus. Does not overwrite other columns."
    },
    {
      "parameters": {
        "jsCode": "// STEP 3 — Calculate cleaning time: start 11:00 AM on cleaningDate, duration 3 hours.\nconst DURATION_HOURS = 3;\nconst item = $input.first().json;\nconst cleaningDateRaw = item.cleaningDate || item.checkOut || '';\nlet startTime;\ntry {\n  const d = new Date(cleaningDateRaw);\n  if (isNaN(d.getTime())) throw new Error('Invalid date');\n  d.setHours(11, 0, 0, 0);\n  startTime = d.toISOString();\n} catch (_) {\n  startTime = new Date().toISOString().replace(/T\\d{2}:\\d{2}:\\d{2}/, 'T11:00:00');\n}\nconst endDate = new Date(startTime);\nendDate.setHours(endDate.getHours() + DURATION_HOURS);\nconst endTime = endDate.toISOString();\nreturn [{ json: { ...item, startTime, endTime, durationHours: DURATION_HOURS } }];"
      },
      "id": "phase2-calculate-time",
      "name": "Calculate Cleaning Time",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1760, 200],
      "notes": "startTime = cleaningDate at 11:00 AM; endTime = startTime + 3h. Change DURATION_HOURS to make configurable."
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict", "version": 1 },
          "conditions": [
            { "id": "has-event", "leftValue": "={{ ($json.calendarEventId ?? '').toString().trim() }}", "rightValue": "", "operator": { "type": "string", "operation": "notEquals" } }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "phase2-if-has-calendar-event",
      "name": "Already Has Calendar Event?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1980, 200],
      "notes": "TRUE = calendarEventId set → skip event creation (and notification). FALSE = create events + notify."
    },
    {
      "parameters": {
        "calendarId": { "__rl": true, "value": "REPLACE_ADMIN_CALENDAR_ID", "mode": "id" },
        "title": "=Cleaning – {{ $json.propertyName || $json.propertyUid }} – {{ $json.guestName || 'Guest' }}",
        "start": "={{ $json.startTime }}",
        "end": "={{ $json.endTime }}",
        "description": "=Property: {{ $json.propertyName || $json.propertyUid }}\nAddress: {{ $json.address || 'See sheet' }}\nGuest Count: {{ $json.adultCount ?? '' }}\nBooking ID: {{ $json.bookingUid }}",
        "options": {}
      },
      "id": "phase2-create-admin-event",
      "name": "Create Admin Calendar Event",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.2,
      "position": [2200, 100],
      "credentials": { "googleCalendarOAuth2Api": { "id": "REPLACE_GOOGLE_CALENDAR_CREDENTIAL_ID", "name": "Google Calendar account" } },
      "notes": "Primary/admin calendar. Set calendarId in parameters (e.g. primary or shared admin calendar)."
    },
    {
      "parameters": {
        "calendarId": { "__rl": true, "value": "={{ $json.cleanerCalendarId }}", "mode": "id" },
        "title": "=Cleaning – {{ $json.propertyName || $json.propertyUid }} – {{ $json.guestName || 'Guest' }}",
        "start": "={{ $json.startTime }}",
        "end": "={{ $json.endTime }}",
        "description": "=Property: {{ $json.propertyName || $json.propertyUid }}\nAddress: {{ $json.address || 'See sheet' }}\nGuest Count: {{ $json.adultCount ?? '' }}\nBooking ID: {{ $json.bookingUid }}",
        "options": {}
      },
      "id": "phase2-create-cleaner-event",
      "name": "Create Cleaner Calendar Event",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.2,
      "position": [2420, 100],
      "credentials": { "googleCalendarOAuth2Api": { "id": "REPLACE_GOOGLE_CALENDAR_CREDENTIAL_ID", "name": "Google Calendar account" } },
      "notes": "Cleaner's calendar. Event ID from response is saved to sheet in next node."
    },
    {
      "parameters": {
        "jsCode": "// Pass through job + calendar event id from cleaner event (for sheet update).\nconst job = $('Calculate Cleaning Time').last().json;\nconst eventResult = $input.first().json;\nconst eventId = eventResult?.id ?? eventResult?.data?.id ?? '';\nreturn [{ json: { ...job, calendarEventId: eventId } }];"
      },
      "id": "phase2-prepare-event-id",
      "name": "Prepare Event Id for Sheet",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2640, 100],
      "notes": "Extracts event ID from Google Calendar create response. Cleaner calendar event ID is source of truth for link."
    },
    {
      "parameters": {
        "operation": "update",
        "documentId": { "__rl": true, "value": "REPLACE_WITH_YOUR_SPREADSHEET_ID", "mode": "id" },
        "sheetName": { "__rl": true, "value": "cleaning_job", "mode": "name" },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "bookingUid": "={{ $json.bookingUid }}",
            "calendarEventId": "={{ $json.calendarEventId }}"
          },
          "matchingColumns": ["bookingUid"]
        },
        "options": {}
      },
      "id": "phase2-update-calendar-event-id",
      "name": "Update Job With Event Id",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.4,
      "position": [2860, 100],
      "credentials": { "googleSheetsOAuth2Api": { "id": "REPLACE_GOOGLE_CREDENTIAL_ID", "name": "Google Sheets account" } },
      "notes": "Writes cleaner calendar event ID to cleaning_job. Used for skip logic and for building calendar link in email."
    },
    {
      "parameters": {
        "sendTo": "={{ $json.cleanerEmail }}",
        "subject": "=New Cleaning Assigned – {{ $('Calculate Cleaning Time').last().json.propertyName || $('Calculate Cleaning Time').last().json.propertyUid }}",
        "emailType": "text",
        "message": "=You have been assigned a new cleaning job.\n\nProperty: {{ $('Calculate Cleaning Time').last().json.propertyName || $('Calculate Cleaning Time').last().json.propertyUid }}\nAddress: {{ $('Calculate Cleaning Time').last().json.address || 'See assignment' }}\nDate: {{ $('Calculate Cleaning Time').last().json.cleaningDate || $('Calculate Cleaning Time').last().json.checkOut }}\nTime: 11:00 AM\nGuest Count: {{ $('Calculate Cleaning Time').last().json.adultCount ?? '' }}\nBooking Reference: {{ $('Calculate Cleaning Time').last().json.bookingUid }}\n\nCalendar Event:\n{{ $json.calendarEventId ? 'https://calendar.google.com/calendar/event?eid=' + encodeURIComponent($json.calendarEventId) : 'Event created – check your calendar' }}\n\nThis email serves as official assignment confirmation.",
        "options": {}
      },
      "id": "phase2-send-gmail",
      "name": "Send Gmail to Cleaner",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [3080, 100],
      "credentials": { "gmailOAuth2": { "id": "REPLACE_GMAIL_CREDENTIAL_ID", "name": "Gmail account" } },
      "notes": "Sends to cleaner email from mapping. Calendar link uses event ID (format may vary by API)."
    },
    {
      "parameters": {},
      "id": "phase2-noop-skip",
      "name": "Skip (Already Has Event)",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [2200, 300],
      "notes": "When calendarEventId already set: no duplicate event, no duplicate email. Rejoin loop."
    }
  ],
  "connections": {
    "Manual Trigger": {
      "main": [[{ "node": "Read Pending Cleaning Jobs", "type": "main", "index": 0 }]]
    },
    "Read Pending Cleaning Jobs": {
      "main": [[{ "node": "Filter Pending Only", "type": "main", "index": 0 }]]
    },
    "Filter Pending Only": {
      "main": [[{ "node": "Split In Batches", "type": "main", "index": 0 }]]
    },
    "Split In Batches": {
      "main": [
        [],
        [[{ "node": "Lookup Reservation", "type": "main", "index": 0 }]]
      ]
    },
    "Lookup Reservation": {
      "main": [[{ "node": "Ensure One Item (Job or Reservation)", "type": "main", "index": 0 }]]
    },
    "Ensure One Item (Job or Reservation)": {
      "main": [[{ "node": "Merge Job and Reservation", "type": "main", "index": 0 }]]
    },
    "Merge Job and Reservation": {
      "main": [[{ "node": "Assign Cleaner", "type": "main", "index": 0 }]]
    },
    "Assign Cleaner": {
      "main": [[{ "node": "Update Job Assigned", "type": "main", "index": 0 }]]
    },
    "Update Job Assigned": {
      "main": [[{ "node": "Calculate Cleaning Time", "type": "main", "index": 0 }]]
    },
    "Calculate Cleaning Time": {
      "main": [[{ "node": "Already Has Calendar Event?", "type": "main", "index": 0 }]]
    },
    "Already Has Calendar Event?": {
      "main": [
        [[{ "node": "Skip (Already Has Event)", "type": "main", "index": 0 }]],
        [[{ "node": "Create Admin Calendar Event", "type": "main", "index": 0 }]]
      ]
    },
    "Skip (Already Has Event)": {
      "main": [[{ "node": "Split In Batches", "type": "main", "index": 0 }]]
    },
    "Create Admin Calendar Event": {
      "main": [[{ "node": "Create Cleaner Calendar Event", "type": "main", "index": 0 }]]
    },
    "Create Cleaner Calendar Event": {
      "main": [[{ "node": "Prepare Event Id for Sheet", "type": "main", "index": 0 }]]
    },
    "Prepare Event Id for Sheet": {
      "main": [[{ "node": "Update Job With Event Id", "type": "main", "index": 0 }]]
    },
    "Update Job With Event Id": {
      "main": [[{ "node": "Send Gmail to Cleaner", "type": "main", "index": 0 }]]
    },
    "Send Gmail to Cleaner": {
      "main": [[{ "node": "Split In Batches", "type": "main", "index": 0 }]]
    }
  },
  "pinData": {},
  "settings": { "executionOrder": "v1" },
  "meta": { "templateCredsSetupCompleted": false },
  "tags": []
}
